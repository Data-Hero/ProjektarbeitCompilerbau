/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options { STATIC = false;}

PARSER_BEGIN(NewAwkParser)
package de.fhdo.fsc.project;

public class NewAwkParser {

}

PARSER_END(NewAwkParser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") > // Skip single line comments
}

// Keywords
TOKEN :
{
    < INT: "int" >
|   < DOUBLE : "double">
|   < FLOAT : "float">
|   < CHAR : "char">
|   < BOOLEAN : "boolean">
|   < STRING : "string" >
|   < TYPE : "type">
|   < VOID : "void" >
|   < NULL: "null">
|   < SMARTSWITCH : "@">
|   < RETURN: "return">
|   < ENUM_SEPERATOR: ",">
|   < EXPRESSION_TERMINATOR: ";">
|   < IF: "if">
|   < ELSE: "else">
|   < WHILE: "while">
|   < FOREACH: "foreach">
|   < IN: "in">
}

// Datatypes
TOKEN :
{
    < #LETTER: ["A"-"Z","_","a"-"z"]>
|   < #DIGIT: ["0"-"9"]>
}

// Selector classes
TOKEN :
{
    < PUNCT: "punct" >
|   < GRAPH: "graph"> // Letters, numbers and punctuation
|   < LOWER: "lower"> // Lowercase Letters
|   < ALPHA: "alpha"> // Letters
|   < ALNUM: "alnum"> // Alphanumerics
|   < PRINT: "print"> // Letters, numb ers, punctuation and whitespace
|   < CNTRL: "cntrl"> // Control characters
|   < SPACE: "space"> // Space characters
|   < BLANK: "blank"> // Space and tab
|   < DIGITS: "digit">// Digits
}

// Literals
TOKEN :
{
    "(" | ")" | "!" | "{" | "}" | "--" | "++" | "+" | "-" | "*" | "/" | "%"
|   <INTEGER_LITERAL: <DECIMAL_LITERAL>>
|   <#DECIMAL_LITERAL: ("+" | "-")? ["1"-"9"] (["0"-"9"])*>
|   <FLOATING_POINT_LITERAL: ("+" | "-")? (["0"-"9"])+ "." (["0"-"9"])*>
|   <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|   <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
|   <TYPE_LITERAL: ">" ( ~["<",">","\\","\n","\r"] | "\\" ( [">", "<", "n","t","b","r","f","\\"] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "<">
}

// Built-in Functions
TOKEN :
{
    < CONTERT_FUNCTION: ( "toBoolean" | "toCharacter" | "toDouble" | "toInteger" | "toString" )>
|   < CHECKTYPE_FUNCTION: ( "isBoolean" | "isCharacter" | "isDouble" | "isInteger" | "isString" )>
|   < LENGTH_FUNCTION: ( "length" )>
}

// Identifier
TOKEN :
{
    < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
}

void compilationUnit():{} {
    (LOOKAHEAD(3) FunctionDefinition())*
    (LOOKAHEAD(2) Statement() | Declaration())+
    <EOF>
}

void Statement():{} {
    WhileStatement()
|   ForeachStatement()
|   IfStatement()
|   Expression() <EXPRESSION_TERMINATOR>
}

void Declaration():{} {
    Datatype() Identifier() [ "=" Expression() ] ";"
}

void Expression():{} {
    LOOKAHEAD(2) <IDENTIFIER> "=" Expression() | LogicalExpression()
}

void LogicalExpression():{} {
    CompareExpression() [("&&" | "||") CompareExpression()]
}

void CompareExpression():{} {
    AdditiveExpression() [("==" | "!=" | "<=" | ">=" | "<" | ">") AdditiveExpression()]
}

// ToDo: do not execute if no 2 values, or flag that no 2 values exist
void AdditiveExpression():{} {
    MultiplicativeExpression() [("+" | "-") AdditiveExpression() ]
}

void MultiplicativeExpression():{} {
    PrefixExpression() [("*" | "/" | "%") MultiplicativeExpression()]
}

void PrefixExpression():{} {
    ["!"] UnaryExpression() [SmartSwitch()] // ToDo: Move SmartSwitch() to a better position?
}

void UnaryExpression():{} {
    LOOKAHEAD(2) "(" Expression() ")"
    | LOOKAHEAD(2) FunctionCallExpression()
    | Atom()
}

void Atom():{} {
    Identifier() ["++"|"--"]
    | ("++"|"--") Identifier()
    | <STRING_LITERAL>
    | <CHARACTER_LITERAL>
    | <TYPE_LITERAL>
    | <INTEGER_LITERAL>
    | <FLOATING_POINT_LITERAL>
    | IsDatatype()
    | ToDatatype()
    | LengthDatatype()
}

void FunctionCallExpression():{} {
    Identifier() "(" [LogicalExpression() (<ENUM_SEPERATOR> LogicalExpression())*] ")"
}

void Identifier():{} {
    <IDENTIFIER>
}

// Function
void FunctionReturnStatement():{} {
    <RETURN> [LogicalExpression()] ";"
}

void FunctionBody():{} {
    "{" (Statement() | Declaration())* (FunctionReturnStatement())? "}"
}

void FunctionHeader():{} {
    ReturnDatatype()
    Identifier()

    "("
    (LOOKAHEAD(2) Datatype()
    Identifier() )?
    (LOOKAHEAD(3) "," Datatype()
    Identifier())*
    ")"
}

void FunctionDefinition():{} {
    FunctionHeader() FunctionBody()
}

void ForeachStatement():{} {
    "foreach" "(" Identifier() <IN> Expression() ")" FunctionBody()
}

void WhileStatement():{} {
    "while" "(" LogicalExpression() ")" FunctionBody()
}

void IfStatement():{} {
    "if" "(" LogicalExpression()  ")" FunctionBody()
    (LOOKAHEAD(2) "else" "if" "(" LogicalExpression() ")" FunctionBody())*
    ("else" FunctionBody())?
}

// Smart Switch
void SmartSwitchSelektor():{} {
    <PUNCT> | <GRAPH> | <LOWER> | <ALPHA> | <ALNUM> | <PRINT> | <CNTRL> | <SPACE> | <BLANK> | <DIGITS>
}


void SmartSwitchCondition():{} {
    ("!" ":" SmartSwitchSelektor() ":") | (":" SmartSwitchSelektor() ":") // 2 functions or OR seem like the only options. What about >>["!"] ":" SmartSwitchSelektor() ":"<< ?
}

void SmartSwitchCase():{} {
    SmartSwitchCondition() FunctionBody()
}

void SmartSwitch():{} {
    <SMARTSWITCH> "{" SmartSwitchCase() "}"
}

// Integrated Funtions
void IsDatatype():{} {
     <CHECKTYPE_FUNCTION> "(" Expression() ")"
}

void ToDatatype():{} {
    <CONTERT_FUNCTION> "(" Expression() ")"
}

void LengthDatatype():{} {
    <LENGTH_FUNCTION> "(" Expression() ")"
}

// Datatype
void BasicDatatype():{} {
    <INT> | <DOUBLE> | <CHAR> | <BOOLEAN> | <STRING> | <TYPE> | <IDENTIFIER>
}


void Datatype():{} {
    BasicDatatype() ("[]")*
}

void ReturnDatatype():{} {
    Datatype() | "void"
}