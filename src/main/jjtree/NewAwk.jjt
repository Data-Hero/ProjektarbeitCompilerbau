/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options { STATIC = false; MULTI=true; VISITOR=true; NODE_EXTENDS="BaseNode";}

PARSER_BEGIN(NewAwkParser)
package de.fhdo.fsc.project;

import de.fhdo.fsc.project.DataType.Types;
import java.io.FileReader;

public class NewAwkParser {
    public static void main(String[] args) {
        try {
                NewAwkParser parser = new NewAwkParser(new FileReader("./src/main/test/test1.na"));
                SimpleNode node = parser.Start();
                node.dump("");
            } catch (Exception e) { System.out.println(e); }
    }
}

PARSER_END(NewAwkParser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") > // Skip single line comments
}

// Keywords
TOKEN :
{
    < INT: "int" >
|   < DOUBLE : "double">
|   < FLOAT : "float">
|   < CHAR : "char">
|   < BOOLEAN : "boolean">
|   < STRING : "string" >
|   < TYPE : "type">
|   < VOID : "void" >
|   < NULL: "null">
|   < SMARTSWITCH : "@">
|   < RETURN: "return">
|   < ENUM_SEPERATOR: ",">
|   < EXPRESSION_TERMINATOR: ";">
|   < IF: "if">
|   < ELSE: "else">
|   < WHILE: "while">
|   < FOREACH: "foreach">
|   < IN: "in">
}

// Datatypes
TOKEN :
{
    < #LETTER: ["A"-"Z","_","a"-"z"]>
|   < #DIGIT: ["0"-"9"]>
}

// Date
TOKEN :
{
    < DATE: < TWO_DIGIT >"-"< TWO_DIGIT>"-"< TWO_DIGIT ><TWO_DIGIT>>
|   < TWO_DIGIT: (["0"-"9"]) {2} >
|   < AMPM: "am"|"pm" >
|   < TIME: <TWO_DIGIT>":"<TWO_DIGIT> >
}

// Selector classes
TOKEN :
{
    < PUNCT: "punct" >
|   < GRAPH: "graph"> // Letters, numbers and punctuation
|   < LOWER: "lower"> // Lowercase Letters
|   < ALPHA: "alpha"> // Letters
|   < ALNUM: "alnum"> // Alphanumerics
|   < PRINT: "print"> // Letters, numb ers, punctuation and whitespace
|   < CNTRL: "cntrl"> // Control characters
|   < SPACE: "space"> // Space characters
|   < BLANK: "blank"> // Space and tab
|   < DIGITS: "digit">// Digits
}

// Literals
TOKEN :
{
    <INTEGER_LITERAL: <DECIMAL_LITERAL>>
|   <#DECIMAL_LITERAL: ("+" | "-")? ["1"-"9"] (["0"-"9"])*>
|   <FLOATING_POINT_LITERAL: ("+" | "-")? (["0"-"9"])+ "." (["0"-"9"])*>
|   <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|   <STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
|   <TYPE_LITERAL: ">" ( ~["<",">","\\","\n","\r"] | "\\" ( [">", "<", "n","t","b","r","f","\\"] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "<">
}

// Built-in Functions
TOKEN :
{
    < CONTERT_FUNCTION: ( "toBoolean" | "toCharacter" | "toDouble" | "toInteger" | "toString" )>
|   < CHECKTYPE_FUNCTION: ( "isBoolean" | "isCharacter" | "isDouble" | "isInteger" | "isString" )>
|   < LENGTH_FUNCTION: ( "length" )>
}

// Identifier
TOKEN :
{
    < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
}

//void DateTime() : {}{<DATE><TIME><AMPM>}

ASTStart Start():{} {
    (LOOKAHEAD(3) FunctionDefinition())*
    (Element())+
    <EOF>
    { return jjtThis; }
}

// Base element
void Element():{} {
    Block()
|   (Expression() <EXPRESSION_TERMINATOR>)
}

// Block elements
void Block():{} {
    WhileLoopDefinition()
|   ForeachLoopDefinition()
|   IfDefinition()
}

// Expressions
void Expression():{} {
    AssingmentExpression()
}
/**
*     < INT: "int" >
  |   < DOUBLE : "double">
  |   < FLOAT : "float">
  |   < CHAR : "char">
  |   < BOOLEAN : "boolean">
  |   < STRING : "string" >
  |   < TYPE : "type">
  |   < VOID : "void" >
*/

void AssingmentExpression():{} {
    VariableDefinitionExpression() ("=" LogicalExpression() { jjtThis.data.put("value", token.image); })*
}

void VariableDefinitionExpression():{} {
    [
        LOOKAHEAD(Datatype() Identifier())
        Datatype() { jjtThis.data.put("type", token.image); }
    ]
    Identifier() { jjtThis.data.put("name", token.image); }
}

void LogicalExpression():{} {
    CompareExpression() [("&&" | "||") LogicalExpression()]
}

void CompareExpression():{} {
    AdditiveExpression() [("==" | "!=" | "<=" | ">=" | "<" | ">") CompareExpression()]
}

// TODO do not execute if no 2 values, or flag that no 2 values exist
void AdditiveExpression():{} {
    MultiplicativeExpression() [("+" | "-") { jjtThis.data.put("sign", token.image); } AdditiveExpression() ]
}

void MultiplicativeExpression():{} {
    PrefixExpression() [("*" | "/") MultiplicativeExpression()]
}

void PowerExpression():{} {
    PrefixExpression() [("**" | "//") PowerExpression() ]
}

void ModuloExpression():{} {
    PrefixExpression() ["%" PowerExpression() ]
}

void PrefixExpression():{} {
    ["!"] UnaryExpression() [SmartSwitchDefinition()] // ToDo: Move SmartSwitchDefinition() to a better position?
}

void UnaryExpression():{} {
    LOOKAHEAD(2) "(" LogicalExpression() ")"
    | LOOKAHEAD(2) FunctionCallExpression()
    | IsDatatype()
    | ToDatatype()
    | LengthDatatype()
    | ValueExpression()
}

void ValueExpression():{} {
    (<STRING_LITERAL>           { jjtThis.data.put("type", Types.stringType);  }
    | <CHARACTER_LITERAL>       { jjtThis.data.put("type", Types.charType);  }
    | <TYPE_LITERAL>            { jjtThis.data.put("type", Types.typeType);  }
    | <INTEGER_LITERAL>         { jjtThis.data.put("type", Types.intType);  }
    | <FLOATING_POINT_LITERAL>  { jjtThis.data.put("type", Types.doubleType);  }
    | <NULL>                    { jjtThis.data.put("type", null);  }
    | Identifier()) { jjtThis.data.put("value", token.image);  }
}

void FunctionCallExpression():{} {
    Identifier() { jjtThis.data.put("identifier", token.image); } "("
    [LogicalExpression()  { jjtThis.data.put("counter",0); jjtThis.data.put("param" + jjtThis.data.get("counter") + "Value", token.image); }
    (<ENUM_SEPERATOR> LogicalExpression())* { jjtThis.data.put("param" + jjtThis.data.get("counter") + "Value", token.image); }]  ")"
}

void StringExpression():{} {
    <STRING_LITERAL>
    | Identifier()
    | <CHARACTER_LITERAL>
    | <INTEGER_LITERAL>
    | <FLOATING_POINT_LITERAL>
    | <NULL>
}

void Identifier():{} {
    <IDENTIFIER>
    {
        jjtThis.data.put("name", token.image);
    }
}

// Function
void FunctionReturnExpression():{} {
    <RETURN> [LogicalExpression() ] <EXPRESSION_TERMINATOR>
}

void FunctionBodyDefinition():{} {
    "{" (Element())* (FunctionReturnExpression())? "}"
}

void FunctionHeaderDefinition():{} {
    ReturnDatatype()  { jjtThis.data.put("returnType", token.image); }
    Identifier() { jjtThis.data.put("identifier", token.image); } "("
    (LOOKAHEAD(2) Datatype() { jjtThis.data.put("counter",0); jjtThis.data.put("param" + jjtThis.data.get("counter") + "Type", token.image); System.out.println(token.image);}
    Identifier() { jjtThis.data.put("param" + jjtThis.data.get("counter") + "Identifier", token.image); jjtThis.data.put("counter",1+(int)jjtThis.data.get("counter"));} )?
    (LOOKAHEAD(3)<ENUM_SEPERATOR> Datatype() { jjtThis.data.put("param" + jjtThis.data.get("counter") + "Type", token.image); }
    Identifier() { jjtThis.data.put("identifier" + jjtThis.data.get("counter") + "Identifier", token.image); jjtThis.data.put("counter",1+(int)jjtThis.data.get("counter"));})* ")"
}

void FunctionDefinition():{} {
    FunctionHeaderDefinition() FunctionBodyDefinition()
}

void ForeachLoopDefinition():{} {
    <FOREACH> "(" Identifier() <IN> UnaryExpression() ")" FunctionBodyDefinition()
}

void WhileLoopDefinition():{} {
    <WHILE> "(" LogicalExpression() ")" FunctionBodyDefinition()
}

void IfDefinition():{} {
    <IF> "(" LogicalExpression()  ")" FunctionBodyDefinition()
    (LOOKAHEAD(2) <ELSE> <IF> "(" LogicalExpression() ")" FunctionBodyDefinition())*
    (<ELSE> FunctionBodyDefinition())?
}

// Smart Switch
void SmartSwitchSelektor():{} {
    <PUNCT> | <GRAPH> | <LOWER> | <ALPHA> | <ALNUM> | <PRINT> | <CNTRL> | <SPACE> | <BLANK> | <DIGITS>
}


void SmartSwitchConditionDefinition():{} {
    ("!" ":" SmartSwitchSelektor() ":") | (":" SmartSwitchSelektor() ":") // 2 functions or OR seem like the only options. What about >>["!"] ":" SmartSwitchSelektor() ":"<< ?
}

void SmartSwitchCaseDefinition():{} {
    SmartSwitchConditionDefinition() FunctionBodyDefinition()
}

void SmartSwitchDefinition():{} {
    <SMARTSWITCH> "{" SmartSwitchCaseDefinition() "}"
}


// Integrated Funtions
void IsDatatype():{} {
     <CHECKTYPE_FUNCTION> { jjtThis.data.put("function", token.image); } "(" UnaryExpression() { jjtThis.data.put("value", token.image); } ")"
}

void ToDatatype():{} {
    <CONTERT_FUNCTION> "(" UnaryExpression() ")"
}

void LengthDatatype():{} {
    <LENGTH_FUNCTION> "(" UnaryExpression() ")"
}

// Datatype
void BasicDatatype():{} {
    <INT> | <DOUBLE> | <CHAR> | <BOOLEAN> | <STRING> | <TYPE> | <IDENTIFIER>
}


void Datatype():{} {
    BasicDatatype() ("[]")*
}

void ReturnDatatype():{} {
    Datatype() | <VOID>
}